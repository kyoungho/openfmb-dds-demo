<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RTI Connext .Net APIs: DDS::Listener Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RTI Connext .Net APIs
   &#160;<span id="projectnumber">Version 5.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classDDS_1_1Listener.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">DDS::Listener Class Reference<div class="ingroups"><a class="el" href="group__DDSDcpsModule.html">RTI Connext DDS API Reference</a> &raquo; <a class="el" href="group__DDSInfrastructureModule.html">Infrastructure Module</a> &raquo; <a class="el" href="group__DDSEntityModule.html">Entity Support</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><em><a class="el" href="group__DDSDocGuideModule.html#a_st_interface">&lt;&lt;interface&gt;&gt;</a></em> Abstract base class for all <a class="el" href="classDDS_1_1Listener.html" title="&lt;&lt;interface&gt;&gt; Abstract base class for all Listener interfaces. ">Listener</a> interfaces.  
 <a href="classDDS_1_1Listener.html#details">More...</a></p>

<p><code>#include &lt;managed_infrastructure.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DDS::Listener:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classDDS_1_1Listener.png" usemap="#DDS::Listener_map" alt=""/>
  <map id="DDS::Listener_map" name="DDS::Listener_map">
<area href="classDDS_1_1DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS::Listener for reader status. " alt="DDS::DataReaderListener" shape="rect" coords="0,56,239,80"/>
<area href="classDDS_1_1DataWriterListener.html" title="&lt;&lt;interface&gt;&gt; DDS::Listener for writer status. " alt="DDS::DataWriterListener" shape="rect" coords="249,56,488,80"/>
<area href="classDDS_1_1TopicListener.html" title="&lt;&lt;interface&gt;&gt; DDS::Listener for DDS::Topic entities. " alt="DDS::TopicListener" shape="rect" coords="498,56,737,80"/>
<area href="classExample_1_1EntityExample_1_1MyEntityListener.html" alt="Example.EntityExample.MyEntityListener" shape="rect" coords="747,56,986,80"/>
<area href="classDDS_1_1SubscriberListener.html" title="&lt;&lt;interface&gt;&gt; DDS::Listener for status about a subscriber. " alt="DDS::SubscriberListener" shape="rect" coords="0,112,239,136"/>
<area href="classDDS_1_1PublisherListener.html" title="&lt;&lt;interface&gt;&gt; DDS::Listener for DDS::Publisher status. " alt="DDS::PublisherListener" shape="rect" coords="249,112,488,136"/>
<area href="classDDS_1_1DomainParticipantListener.html" title="&lt;&lt;interface&gt;&gt; Listener for participant status. " alt="DDS::DomainParticipantListener" shape="rect" coords="498,112,737,136"/>
<area href="classDDS_1_1DomainParticipantListener.html" title="&lt;&lt;interface&gt;&gt; Listener for participant status. " alt="DDS::DomainParticipantListener" shape="rect" coords="0,168,239,192"/>
<area href="classDDS_1_1DomainParticipantListener.html" title="&lt;&lt;interface&gt;&gt; Listener for participant status. " alt="DDS::DomainParticipantListener" shape="rect" coords="249,168,488,192"/>
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><em><a class="el" href="group__DDSDocGuideModule.html#a_st_interface">&lt;&lt;interface&gt;&gt;</a></em> Abstract base class for all <a class="el" href="classDDS_1_1Listener.html" title="&lt;&lt;interface&gt;&gt; Abstract base class for all Listener interfaces. ">Listener</a> interfaces. </p>
<dl class="section user"><dt>Entity:</dt><dd><a class="el" href="classDDS_1_1Entity.html" title="&lt;&lt;interface&gt;&gt; Abstract base class for all the DDS objects that support QoS policies, a listener, and a status condition. ">DDS::Entity</a> </dd></dl>
<dl class="section user"><dt>QoS:</dt><dd><a class="el" href="group__DDSQosTypesModule.html">QoS Policies</a> </dd></dl>
<dl class="section user"><dt>Status:</dt><dd><a class="el" href="group__DDSStatusTypesModule.html">Status Kinds</a> </dd></dl>
<p>All the supported kinds of concrete <a class="el" href="classDDS_1_1Listener.html" title="&lt;&lt;interface&gt;&gt; Abstract base class for all Listener interfaces. ">DDS::Listener</a> interfaces (one per concrete <a class="el" href="classDDS_1_1Entity.html" title="&lt;&lt;interface&gt;&gt; Abstract base class for all the DDS objects that support QoS policies, a listener, and a status condition. ">DDS::Entity</a> type) derive from this root and add methods whose prototype depends on the concrete <a class="el" href="classDDS_1_1Listener.html" title="&lt;&lt;interface&gt;&gt; Abstract base class for all Listener interfaces. ">Listener</a>. </p>
<p>Listeners provide a way for <a class="el" href="namespaceRTI.html">RTI</a> Connext to asynchronously alert the application when there are relevant status changes. </p>
<p>Almost every application will have to implement listener interfaces. </p>
<p>Each dedicated listener presents a list of operations that correspond to the relevant communication status changes to which an application may respond. </p>
<p>The same <a class="el" href="classDDS_1_1Listener.html" title="&lt;&lt;interface&gt;&gt; Abstract base class for all Listener interfaces. ">DDS::Listener</a> instance may be shared among multiple entities if you so desire. Consequently, the provided parameter contains a reference to the concerned <a class="el" href="classDDS_1_1Entity.html" title="&lt;&lt;interface&gt;&gt; Abstract base class for all the DDS objects that support QoS policies, a listener, and a status condition. ">DDS::Entity</a>. </p>
<h1><a class="anchor" id="Listener_plain"></a>
Access to Plain Communication Status</h1>
<p>The general mapping between the plain communication statuses (see <a class="el" href="group__DDSStatusTypesModule.html">Status Kinds</a>) and the listeners' operations is as follows: </p>
<ul>
<li>For each communication status, there is a corresponding operation whose name is <code>on_&lt;communication_status&gt;</code>(), which takes a parameter of type <code>&lt;communication_status&gt;</code> as listed in <a class="el" href="group__DDSStatusTypesModule.html">Status Kinds</a>. </li>
</ul>
<ul>
<li><code>on_&lt;communication_status&gt;</code> is available on the relevant <a class="el" href="classDDS_1_1Entity.html" title="&lt;&lt;interface&gt;&gt; Abstract base class for all the DDS objects that support QoS policies, a listener, and a status condition. ">DDS::Entity</a> as well as those that embed it, as expressed in the following figure: </li>
</ul>
<div class="image">
<img src="DDSListenerDispatching.png" alt="DDSListenerDispatching.png"/>
<div class="caption">
Hierarchical listener processing. The most <em>specific</em> relevant enabled listener is called.</div></div>
<ul>
<li>When the application attaches a listener on an entity, it must set a mask. The mask indicates to <a class="el" href="namespaceRTI.html">RTI</a> Connext which operations are enabled within the listener (cf. operation <a class="el" href="classDDS_1_1Entity.html" title="&lt;&lt;interface&gt;&gt; Abstract base class for all the DDS objects that support QoS policies, a listener, and a status condition. ">DDS::Entity</a> set_listener() ). </li>
</ul>
<ul>
<li>When a plain communication status changes, <a class="el" href="namespaceRTI.html">RTI</a> Connext triggers the most specific relevant listener operation that is enabled. In case the most specific relevant listener operation corresponds to an application-installed 'nil' listener the operation will be considered handled by a NO-OP operation that does not reset the communication status. </li>
</ul>
<p>This behavior allows the application to set a default behavior (e.g., in the listener associated with the <a class="el" href="classDDS_1_1DomainParticipant.html" title="&lt;&lt;interface&gt;&gt; Container for all DDS::DomainEntity objects. ">DDS::DomainParticipant</a>) and to set dedicated behaviors only where needed. </p>
<h1><a class="anchor" id="Listener_read"></a>
Access to Read Communication Status</h1>
<p>The two statuses related to data arrival are treated slightly differently. Since they constitute the core purpose of the Data Distribution Service, there is no need to provide a default mechanism (as is done for the plain communication statuses above). </p>
<p>The rule is as follows. Each time the read communication status changes: </p>
<ul>
<li>First, <a class="el" href="namespaceRTI.html">RTI</a> Connext tries to trigger the <a class="el" href="classDDS_1_1SubscriberListener.html#af6f3411a8a353178b513ece3c7885abf" title="Handles the DDS::StatudKind::DATA_ON_READERS_STATUS communication status. ">DDS::SubscriberListener::on_data_on_readers</a> with a parameter of the related <a class="el" href="classDDS_1_1Subscriber.html" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS::Subscriber</a>; </li>
</ul>
<ul>
<li>If this does not succeed (there is no listener or the operation is not enabled), <a class="el" href="namespaceRTI.html">RTI</a> Connext tries to trigger <a class="el" href="classDDS_1_1DataReaderListener.html#afa3b27e5d40df092a54ff1573f23c862" title="Handle the DDS::StatudKind::DATA_AVAILABLE_STATUS communication status. ">DDS::DataReaderListener::on_data_available</a> on all the related <a class="el" href="classDDS_1_1DataReaderListener.html" title="&lt;&lt;interface&gt;&gt; DDS::Listener for reader status. ">DDS::DataReaderListener</a> objects, with a parameter of the related <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a>. </li>
</ul>
<p>The rationale is that either the application is interested in relations among data arrivals and it must use the first option (and then get the corresponding <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> objects by calling <a class="el" href="classDDS_1_1Subscriber.html#a06ef0d0453e6fc65c0a4b9212e3d634e" title="Allows the application to access the DDS::DataReader objects that contain samples with the specified ...">DDS::Subscriber::get_datareaders</a> on the related <a class="el" href="classDDS_1_1Subscriber.html" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS::Subscriber</a> and then get the data by calling <a class="el" href="classDDS_1_1TypedDataReader.html#a246446798ef356f99fa05ea8a4c5df6a" title="Access a collection of data samples from the DDS::DataReader. ">DDS::TypedDataReader::read</a> or <a class="el" href="classDDS_1_1TypedDataReader.html#aaed9fdf9e5442732cd3a2dae0e606043" title="Access a collection of data-samples from the DDS::DataReader. ">DDS::TypedDataReader::take</a> on the returned <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> objects), or it wants to treat each <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> independently and it may choose the second option (and then get the data by calling <a class="el" href="classDDS_1_1TypedDataReader.html#a246446798ef356f99fa05ea8a4c5df6a" title="Access a collection of data samples from the DDS::DataReader. ">DDS::TypedDataReader::read</a> or <a class="el" href="classDDS_1_1TypedDataReader.html#aaed9fdf9e5442732cd3a2dae0e606043" title="Access a collection of data-samples from the DDS::DataReader. ">DDS::TypedDataReader::take</a> on the related <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a>). </p>
<p>Note that if <a class="el" href="classDDS_1_1SubscriberListener.html#af6f3411a8a353178b513ece3c7885abf" title="Handles the DDS::StatudKind::DATA_ON_READERS_STATUS communication status. ">DDS::SubscriberListener::on_data_on_readers</a> is called, <a class="el" href="namespaceRTI.html">RTI</a> Connext will <em>not</em> try to call <a class="el" href="classDDS_1_1DataReaderListener.html#afa3b27e5d40df092a54ff1573f23c862" title="Handle the DDS::StatudKind::DATA_AVAILABLE_STATUS communication status. ">DDS::DataReaderListener::on_data_available</a>. However, an application can force a call to the <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> objects that have data by calling <a class="el" href="classDDS_1_1Subscriber.html#ac2de8ab79ca9901a935bd760c4a25cc2" title="Invokes the operation DDS::DataReaderListener::on_data_available() on the DDS::DataReaderListener obj...">DDS::Subscriber::notify_datareaders</a>. </p>
<h1><a class="anchor" id="SharedEACallbackRules"></a>
Operations Allowed in Listener Callbacks</h1>
<p>The operations that are allowed in <a class="el" href="classDDS_1_1Listener.html" title="&lt;&lt;interface&gt;&gt; Abstract base class for all Listener interfaces. ">DDS::Listener</a> callbacks depend on the <a class="el" href="structDDS_1_1ExclusiveAreaQosPolicy.html" title="Configures multi-thread concurrency and deadlock prevention capabilities. ">DDS::ExclusiveAreaQosPolicy</a> QoS policy of the <a class="el" href="classDDS_1_1Entity.html" title="&lt;&lt;interface&gt;&gt; Abstract base class for all the DDS objects that support QoS policies, a listener, and a status condition. ">DDS::Entity</a> to which the <a class="el" href="classDDS_1_1Listener.html" title="&lt;&lt;interface&gt;&gt; Abstract base class for all Listener interfaces. ">DDS::Listener</a> is attached &ndash; or in the case of a <a class="el" href="classDDS_1_1DataWriter.html" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS::T...">DDS::DataWriter</a> of <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> listener, on the <a class="el" href="structDDS_1_1ExclusiveAreaQosPolicy.html" title="Configures multi-thread concurrency and deadlock prevention capabilities. ">DDS::ExclusiveAreaQosPolicy</a> QoS of the parent <a class="el" href="classDDS_1_1Publisher.html" title="&lt;&lt;interface&gt;&gt; A publisher is the object responsible for the actual dissemination of publications...">DDS::Publisher</a> or <a class="el" href="classDDS_1_1Subscriber.html" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS::Subscriber</a>. For instance, the <a class="el" href="structDDS_1_1ExclusiveAreaQosPolicy.html" title="Configures multi-thread concurrency and deadlock prevention capabilities. ">DDS::ExclusiveAreaQosPolicy</a> settings of a <a class="el" href="classDDS_1_1Subscriber.html" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS::Subscriber</a> will determine which operations are allowed within the callbacks of the listeners associated with all the DataReaders created through that <a class="el" href="classDDS_1_1Subscriber.html" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS::Subscriber</a>. </p>
<p>Note: these restrictions do not apply to builtin topic listener callbacks. </p>
<p>Regardless of whether <a class="el" href="structDDS_1_1ExclusiveAreaQosPolicy.html#a23f54fecf3f0be4dbf5726040eee965c" title="Whether the DDS::Entity is protected by its own exclusive area or the shared exclusive area...">DDS::ExclusiveAreaQosPolicy::use_shared_exclusive_area</a> is set to true or false, the following operations are <em>not</em> allowed: </p><ul>
<li>
Within any listener callback, deleting the entity to which the <a class="el" href="classDDS_1_1Listener.html" title="&lt;&lt;interface&gt;&gt; Abstract base class for all Listener interfaces. ">DDS::Listener</a> is attached </li>
<li>
Within a <a class="el" href="classDDS_1_1Topic.html" title="&lt;&lt;interface&gt;&gt; The most basic description of the data to be published and subscribed. ">DDS::Topic</a> listener callback, any operations on any subscribers, readers, publishers or writers </li>
</ul>
<p>An attempt to call a disallowed method from within a callback will result in <a class="el" href="classDDS_1_1Retcode__IllegalOperation.html" title="The operation was called under improper circumstances. ">DDS::Retcode_IllegalOperation</a>. </p>
<p>If <a class="el" href="structDDS_1_1ExclusiveAreaQosPolicy.html#a23f54fecf3f0be4dbf5726040eee965c" title="Whether the DDS::Entity is protected by its own exclusive area or the shared exclusive area...">DDS::ExclusiveAreaQosPolicy::use_shared_exclusive_area</a> is set to false, the setting which allows more concurrency among <a class="el" href="namespaceRTI.html">RTI</a> Connext threads, the following are <em>not</em> allowed: </p><ul>
<li>
Within any listener callback, creating any entity </li>
<li>
Within any listener callback, deleting any entity </li>
<li>
Within any listener callback, enabling any entity </li>
<li>
Within any listener callback, setting the QoS of any entities </li>
<li>
Within a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> or <a class="el" href="classDDS_1_1Subscriber.html" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS::Subscriber</a> listener callback, invoking any operation on any other <a class="el" href="classDDS_1_1Subscriber.html" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS::Subscriber</a> or on any <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> belonging to another <a class="el" href="classDDS_1_1Subscriber.html" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS::Subscriber</a>. </li>
<li>
Within a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> or <a class="el" href="classDDS_1_1Subscriber.html" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS::Subscriber</a> listener callback, invoking any operation on any <a class="el" href="classDDS_1_1Publisher.html" title="&lt;&lt;interface&gt;&gt; A publisher is the object responsible for the actual dissemination of publications...">DDS::Publisher</a> (or on any <a class="el" href="classDDS_1_1DataWriter.html" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS::T...">DDS::DataWriter</a> belonging to such a <a class="el" href="classDDS_1_1Publisher.html" title="&lt;&lt;interface&gt;&gt; A publisher is the object responsible for the actual dissemination of publications...">DDS::Publisher</a>) that has <a class="el" href="structDDS_1_1ExclusiveAreaQosPolicy.html#a23f54fecf3f0be4dbf5726040eee965c" title="Whether the DDS::Entity is protected by its own exclusive area or the shared exclusive area...">DDS::ExclusiveAreaQosPolicy::use_shared_exclusive_area</a> set to true. </li>
<li>
Within a <a class="el" href="classDDS_1_1DataWriter.html" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS::T...">DDS::DataWriter</a> of <a class="el" href="classDDS_1_1Publisher.html" title="&lt;&lt;interface&gt;&gt; A publisher is the object responsible for the actual dissemination of publications...">DDS::Publisher</a> listener callback, invoking any operation on another <a class="el" href="classDDS_1_1Publisher.html" title="&lt;&lt;interface&gt;&gt; A publisher is the object responsible for the actual dissemination of publications...">Publisher</a> or on a <a class="el" href="classDDS_1_1DataWriter.html" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS::T...">DDS::DataWriter</a> belonging to another <a class="el" href="classDDS_1_1Publisher.html" title="&lt;&lt;interface&gt;&gt; A publisher is the object responsible for the actual dissemination of publications...">DDS::Publisher</a>. </li>
<li>
Within a <a class="el" href="classDDS_1_1DataWriter.html" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS::T...">DDS::DataWriter</a> of <a class="el" href="classDDS_1_1Publisher.html" title="&lt;&lt;interface&gt;&gt; A publisher is the object responsible for the actual dissemination of publications...">DDS::Publisher</a> listener callback, invoking any operation on any <a class="el" href="classDDS_1_1Subscriber.html" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS::Subscriber</a> or <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a>. </li>
</ul>
<p>An attempt to call a disallowed method from within a callback will result in <a class="el" href="classDDS_1_1Retcode__IllegalOperation.html" title="The operation was called under improper circumstances. ">DDS::Retcode_IllegalOperation</a>. </p>
<p>The above limitations can be lifted by setting <a class="el" href="structDDS_1_1ExclusiveAreaQosPolicy.html#a23f54fecf3f0be4dbf5726040eee965c" title="Whether the DDS::Entity is protected by its own exclusive area or the shared exclusive area...">DDS::ExclusiveAreaQosPolicy::use_shared_exclusive_area</a> to true on the <a class="el" href="classDDS_1_1Publisher.html" title="&lt;&lt;interface&gt;&gt; A publisher is the object responsible for the actual dissemination of publications...">DDS::Publisher</a> or <a class="el" href="classDDS_1_1Subscriber.html" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS::Subscriber</a> (or on the <a class="el" href="classDDS_1_1Publisher.html" title="&lt;&lt;interface&gt;&gt; A publisher is the object responsible for the actual dissemination of publications...">DDS::Publisher</a> or <a class="el" href="classDDS_1_1Subscriber.html" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS::Subscriber</a> of the <a class="el" href="classDDS_1_1DataWriter.html" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS::T...">DDS::DataWriter</a> or <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a>) to which the listener is attached. However, the application will pay the cost of reduced concurrency between the affected publishers and subscribers. </p>
<h1><a class="anchor" id="BestPracticesListeners"></a>
Best Practices with Listeners</h1>
<p>Note that all the issues described below are avoided by using <a class="el" href="classDDS_1_1WaitSet.html" title="&lt;&lt;interface&gt;&gt; Allows an application to wait until one or more of the attached DDS::Condition objects ...">DDS::WaitSet</a>. </p>
<p><b>Avoid blocking or performing a lot of processing in <a class="el" href="classDDS_1_1Listener.html" title="&lt;&lt;interface&gt;&gt; Abstract base class for all Listener interfaces. ">Listener</a> callbacks</b> </p>
<p>Listeners are invoked by internal threads that perform critical functions within the middleware and need to run in a timely manner. By default, Connext DDS creates a few threads to use to receive data and only a single thread to handle periodic events. </p>
<p>Because of this, user applications installing Listeners should never block in a <a class="el" href="classDDS_1_1Listener.html" title="&lt;&lt;interface&gt;&gt; Abstract base class for all Listener interfaces. ">Listener</a> callback. There are several negative consequences of blocking in a listener callback: </p>
<ul>
<li>
The application may lose data for the <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DataReader</a> the listener is installed on, because the receive thread is not removing it from the socket buffer and it gets overwritten. </li>
<li>
The application may receive strictly reliable data with a delay, because the receive thread is not removing it from the socket buffer and if it gets overwritten it must be re-sent. </li>
<li>
The application may lose or delay data for other DataReaders, because by default all DataReaders created with the same <a class="el" href="classDDS_1_1DomainParticipant.html" title="&lt;&lt;interface&gt;&gt; Container for all DDS::DomainEntity objects. ">DomainParticipant</a> share the same threads. </li>
<li>
The application may not be notified of periodic events on time </li>
</ul>
<p>If the application needs to make a blocking call when data is available, or when another event occurs, the application should use <a class="el" href="classDDS_1_1WaitSet.html" title="&lt;&lt;interface&gt;&gt; Allows an application to wait until one or more of the attached DDS::Condition objects ...">DDS::WaitSet</a>. </p>
<p><b>Avoid taking application mutexes/semaphores in <a class="el" href="classDDS_1_1Listener.html" title="&lt;&lt;interface&gt;&gt; Abstract base class for all Listener interfaces. ">Listener</a> callbacks</b> </p>
<p>Taking application mutexes/sempahores within a <a class="el" href="classDDS_1_1Listener.html" title="&lt;&lt;interface&gt;&gt; Abstract base class for all Listener interfaces. ">Listener</a> callback may lead to unexpected deadlock scenarios. </p>
<p>When a <a class="el" href="classDDS_1_1Listener.html" title="&lt;&lt;interface&gt;&gt; Abstract base class for all Listener interfaces. ">Listener</a> callback is invoked the EA (Exclusive Area) of the <a class="el" href="classDDS_1_1Entity.html" title="&lt;&lt;interface&gt;&gt; Abstract base class for all the DDS objects that support QoS policies, a listener, and a status condition. ">Entity</a> 'E' to which the callback applies is taken by the middleware. </p>
<p>If the application takes an application mutex 'M' within a critical section in which the application makes DDS calls affecting 'E', this may lead to following deadlock: </p>
<p>The middleware thread is within the entity EA trying to acquire the mutex 'M'. At the same time, the application thread has acquired 'M' and is blocked trying to acquire the entity EA. </p>
<p><b>Do not write data with a <a class="el" href="classDDS_1_1DataWriter.html" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS::T...">DataWriter</a> within the on_data_available callback</b> </p>
<p>Avoid writing data with a <a class="el" href="classDDS_1_1DataWriter.html" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS::T...">DataWriter</a> within the <a class="el" href="classDDS_1_1DataReaderListener.html#afa3b27e5d40df092a54ff1573f23c862" title="Handle the DDS::StatudKind::DATA_AVAILABLE_STATUS communication status. ">DDS::DataReaderListener::on_data_available()</a> callback. If the write operation blocks because e.g. the send window is full, this will lead to a deadlock. </p>
<p><b>Do not call wait_for_acknowledgements within the on_data_available callback</b> </p>
<p>Do not call the <a class="el" href="classDDS_1_1DataWriter.html#a1f7e2120b3d9eb06244be8d8cb2abc07" title="Blocks the calling thread until all data written by reliable DDS::DataWriter entity is acknowledged...">DDS::DataWriter::wait_for_acknowledgments</a> within the <a class="el" href="classDDS_1_1DataReaderListener.html#afa3b27e5d40df092a54ff1573f23c862" title="Handle the DDS::StatudKind::DATA_AVAILABLE_STATUS communication status. ">DDS::DataReaderListener::on_data_available()</a> callback. This will lead to deadlock. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DDSExclusiveAreaQosModule.html">EXCLUSIVE_AREA</a> </dd>
<dd>
<a class="el" href="group__DDSStatusTypesModule.html">Status Kinds</a> </dd>
<dd>
<a class="el" href="classDDS_1_1WaitSet.html" title="&lt;&lt;interface&gt;&gt; Allows an application to wait until one or more of the attached DDS::Condition objects ...">DDS::WaitSet</a>, <a class="el" href="classDDS_1_1Condition.html" title="&lt;&lt;interface&gt;&gt; Root class for all the conditions that may be attached to a DDS::WaitSet. ">DDS::Condition</a> </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<HR>
<IMG SRC="rti_logo.gif" height="16">
<A HREF="main.html">RTI Connext .Net APIs Version 5.3.0</A>
Copyright &copy; Sun Jun 25 2017 
<A HREF="http://www.rti.com">Real-Time Innovations, Inc</A>
</BODY>
</HTML>
