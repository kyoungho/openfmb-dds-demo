<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RTI Connext .Net APIs: DDS::DataReaderResourceLimitsQosPolicy Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RTI Connext .Net APIs
   &#160;<span id="projectnumber">Version 5.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structDDS_1_1DataReaderResourceLimitsQosPolicy.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="structDDS_1_1DataReaderResourceLimitsQosPolicy-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DDS::DataReaderResourceLimitsQosPolicy Struct Reference<div class="ingroups"><a class="el" href="group__DDSDcpsModule.html">RTI Connext DDS API Reference</a> &raquo; <a class="el" href="group__DDSInfrastructureModule.html">Infrastructure Module</a> &raquo; <a class="el" href="group__DDSQosTypesModule.html">QoS Policies</a> &raquo; <a class="el" href="group__DDSDataReaderResourceLimitsQosModule.html">DATA_READER_RESOURCE_LIMITS</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Various settings that configure how a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> allocates and uses physical memory for internal resources.  
 <a href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#details">More...</a></p>

<p><code>#include &lt;managed_infrastructure.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gafc0c88155b9758b9bbd944bfe39b8603"><td class="memItemLeft" align="right" valign="top">static System::String ^&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSDataReaderResourceLimitsQosModule.html#gafc0c88155b9758b9bbd944bfe39b8603">get_datareaderresourcelimits_qos_policy_name</a> ()</td></tr>
<tr class="memdesc:gafc0c88155b9758b9bbd944bfe39b8603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stringified human-readable name for <a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html" title="Various settings that configure how a DDS::DataReader allocates and uses physical memory for internal...">DDS::DataReaderResourceLimitsQosPolicy</a>.  <a href="group__DDSDataReaderResourceLimitsQosModule.html#gafc0c88155b9758b9bbd944bfe39b8603">More...</a><br /></td></tr>
<tr class="separator:gafc0c88155b9758b9bbd944bfe39b8603"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a5f57b1e4f05c3c4f6de0715b6c4e1557"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a5f57b1e4f05c3c4f6de0715b6c4e1557">max_remote_writers</a></td></tr>
<tr class="memdesc:a5f57b1e4f05c3c4f6de0715b6c4e1557"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of remote writers from which a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> may read, including all instances.  <a href="#a5f57b1e4f05c3c4f6de0715b6c4e1557">More...</a><br /></td></tr>
<tr class="separator:a5f57b1e4f05c3c4f6de0715b6c4e1557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab70a031ea118a15dd73b568ba191b5d"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#aab70a031ea118a15dd73b568ba191b5d">max_remote_writers_per_instance</a></td></tr>
<tr class="memdesc:aab70a031ea118a15dd73b568ba191b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of remote writers from which a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> may read a single instance.  <a href="#aab70a031ea118a15dd73b568ba191b5d">More...</a><br /></td></tr>
<tr class="separator:aab70a031ea118a15dd73b568ba191b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b364722d6cbbf8b11c1a0619bc4e5a"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#ab6b364722d6cbbf8b11c1a0619bc4e5a">max_samples_per_remote_writer</a></td></tr>
<tr class="memdesc:ab6b364722d6cbbf8b11c1a0619bc4e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of out-of-order samples from a given remote <a class="el" href="classDDS_1_1DataWriter.html" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS::T...">DDS::DataWriter</a> that a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> may store when maintaining a reliable connection to the <a class="el" href="classDDS_1_1DataWriter.html" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS::T...">DDS::DataWriter</a>.  <a href="#ab6b364722d6cbbf8b11c1a0619bc4e5a">More...</a><br /></td></tr>
<tr class="separator:ab6b364722d6cbbf8b11c1a0619bc4e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdd444deb92af8c9ac5761ea92c9ba2"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#abcdd444deb92af8c9ac5761ea92c9ba2">max_infos</a></td></tr>
<tr class="memdesc:abcdd444deb92af8c9ac5761ea92c9ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of info units that a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> can use to store <a class="el" href="classDDS_1_1SampleInfo.html" title="Information that accompanies each sample that is read or taken. ">DDS::SampleInfo</a>.  <a href="#abcdd444deb92af8c9ac5761ea92c9ba2">More...</a><br /></td></tr>
<tr class="separator:abcdd444deb92af8c9ac5761ea92c9ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2be6e7ad0a8d568d76b42cfd6406d8"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a7e2be6e7ad0a8d568d76b42cfd6406d8">initial_remote_writers</a></td></tr>
<tr class="memdesc:a7e2be6e7ad0a8d568d76b42cfd6406d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial number of remote writers from which a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> may read, including all instances.  <a href="#a7e2be6e7ad0a8d568d76b42cfd6406d8">More...</a><br /></td></tr>
<tr class="separator:a7e2be6e7ad0a8d568d76b42cfd6406d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f69e4c7da43e1013af9175357b778a7"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a0f69e4c7da43e1013af9175357b778a7">initial_remote_writers_per_instance</a></td></tr>
<tr class="memdesc:a0f69e4c7da43e1013af9175357b778a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial number of remote writers from which a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> may read a single instance.  <a href="#a0f69e4c7da43e1013af9175357b778a7">More...</a><br /></td></tr>
<tr class="separator:a0f69e4c7da43e1013af9175357b778a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14640233f62cb33b02bfef85bf4e9ce3"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a14640233f62cb33b02bfef85bf4e9ce3">initial_infos</a></td></tr>
<tr class="memdesc:a14640233f62cb33b02bfef85bf4e9ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial number of info units that a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> can have, which are used to store <a class="el" href="classDDS_1_1SampleInfo.html" title="Information that accompanies each sample that is read or taken. ">DDS::SampleInfo</a>.  <a href="#a14640233f62cb33b02bfef85bf4e9ce3">More...</a><br /></td></tr>
<tr class="separator:a14640233f62cb33b02bfef85bf4e9ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca67d5c4a2afc4a709d0e9708f0ef26"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#aaca67d5c4a2afc4a709d0e9708f0ef26">initial_outstanding_reads</a></td></tr>
<tr class="memdesc:aaca67d5c4a2afc4a709d0e9708f0ef26"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial number of outstanding calls to read/take (or one of their variants) on the same <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> for which memory has not been returned by calling <a class="el" href="classDDS_1_1TypedDataReader.html#aa4a65c964bb5839b80452e5c2da98175" title="Indicates to the DDS::DataReader that the application is done accessing the collection of received_da...">DDS::TypedDataReader::return_loan</a>.  <a href="#aaca67d5c4a2afc4a709d0e9708f0ef26">More...</a><br /></td></tr>
<tr class="separator:aaca67d5c4a2afc4a709d0e9708f0ef26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c643911069a1b96f7812fb01d7b185"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a79c643911069a1b96f7812fb01d7b185">max_outstanding_reads</a></td></tr>
<tr class="memdesc:a79c643911069a1b96f7812fb01d7b185"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of outstanding read/take calls (or one of their variants) on the same <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> for which memory has not been returned by calling <a class="el" href="classDDS_1_1TypedDataReader.html#aa4a65c964bb5839b80452e5c2da98175" title="Indicates to the DDS::DataReader that the application is done accessing the collection of received_da...">DDS::TypedDataReader::return_loan</a>.  <a href="#a79c643911069a1b96f7812fb01d7b185">More...</a><br /></td></tr>
<tr class="separator:a79c643911069a1b96f7812fb01d7b185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb4995f9adb75d1466605e684655d3a"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a3cb4995f9adb75d1466605e684655d3a">max_samples_per_read</a></td></tr>
<tr class="memdesc:a3cb4995f9adb75d1466605e684655d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of data samples that the application can receive from the middleware in a single call to <a class="el" href="classDDS_1_1TypedDataReader.html#a246446798ef356f99fa05ea8a4c5df6a" title="Access a collection of data samples from the DDS::DataReader. ">DDS::TypedDataReader::read</a> or <a class="el" href="classDDS_1_1TypedDataReader.html#aaed9fdf9e5442732cd3a2dae0e606043" title="Access a collection of data-samples from the DDS::DataReader. ">DDS::TypedDataReader::take</a>. If more data exists in the middleware, the application will need to issue multiple read/take calls.  <a href="#a3cb4995f9adb75d1466605e684655d3a">More...</a><br /></td></tr>
<tr class="separator:a3cb4995f9adb75d1466605e684655d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83759e3f07a3879b0f53f438f7a9761"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#ae83759e3f07a3879b0f53f438f7a9761">max_fragmented_samples</a></td></tr>
<tr class="memdesc:ae83759e3f07a3879b0f53f438f7a9761"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of samples for which the <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> may store fragments at a given point in time.  <a href="#ae83759e3f07a3879b0f53f438f7a9761">More...</a><br /></td></tr>
<tr class="separator:ae83759e3f07a3879b0f53f438f7a9761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493dff26d01c8d6951313253a67b1e2b"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a493dff26d01c8d6951313253a67b1e2b">initial_fragmented_samples</a></td></tr>
<tr class="memdesc:a493dff26d01c8d6951313253a67b1e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial number of samples for which a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> may store fragments.  <a href="#a493dff26d01c8d6951313253a67b1e2b">More...</a><br /></td></tr>
<tr class="separator:a493dff26d01c8d6951313253a67b1e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8a81f8b0e91b7e016f11882342bd69"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#aea8a81f8b0e91b7e016f11882342bd69">max_fragmented_samples_per_remote_writer</a></td></tr>
<tr class="memdesc:aea8a81f8b0e91b7e016f11882342bd69"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of samples per remote writer for which a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> may store fragments.  <a href="#aea8a81f8b0e91b7e016f11882342bd69">More...</a><br /></td></tr>
<tr class="separator:aea8a81f8b0e91b7e016f11882342bd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f42abe5e3cbf5306eeaeae5811f2ca"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#ad9f42abe5e3cbf5306eeaeae5811f2ca">max_fragments_per_sample</a></td></tr>
<tr class="memdesc:ad9f42abe5e3cbf5306eeaeae5811f2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of fragments for a single sample.  <a href="#ad9f42abe5e3cbf5306eeaeae5811f2ca">More...</a><br /></td></tr>
<tr class="separator:ad9f42abe5e3cbf5306eeaeae5811f2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d244479c2f9e22add97287395f9f9fe"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a1d244479c2f9e22add97287395f9f9fe">max_total_instances</a></td></tr>
<tr class="memdesc:a1d244479c2f9e22add97287395f9f9fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of instances for which a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DataReader</a> will keep state.  <a href="#a1d244479c2f9e22add97287395f9f9fe">More...</a><br /></td></tr>
<tr class="separator:a1d244479c2f9e22add97287395f9f9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af32ce6df34f0adf64bb83d56ead4ce"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a7af32ce6df34f0adf64bb83d56ead4ce">max_remote_virtual_writers</a></td></tr>
<tr class="memdesc:a7af32ce6df34f0adf64bb83d56ead4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of remote virtual writers from which a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> may read, including all instances.  <a href="#a7af32ce6df34f0adf64bb83d56ead4ce">More...</a><br /></td></tr>
<tr class="separator:a7af32ce6df34f0adf64bb83d56ead4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cf9a7172bac66444f39e5b41e3b8d2"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a30cf9a7172bac66444f39e5b41e3b8d2">initial_remote_virtual_writers</a></td></tr>
<tr class="memdesc:a30cf9a7172bac66444f39e5b41e3b8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial number of remote virtual writers from which a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> may read, including all instances.  <a href="#a30cf9a7172bac66444f39e5b41e3b8d2">More...</a><br /></td></tr>
<tr class="separator:a30cf9a7172bac66444f39e5b41e3b8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297e95e927beb073eed8bb499303bfd3"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a297e95e927beb073eed8bb499303bfd3">max_remote_virtual_writers_per_instance</a></td></tr>
<tr class="memdesc:a297e95e927beb073eed8bb499303bfd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of virtual remote writers that can be associated with an instance.  <a href="#a297e95e927beb073eed8bb499303bfd3">More...</a><br /></td></tr>
<tr class="separator:a297e95e927beb073eed8bb499303bfd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf46cdc2fb411c33898ec61e3b0cb47e"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#abf46cdc2fb411c33898ec61e3b0cb47e">initial_remote_virtual_writers_per_instance</a></td></tr>
<tr class="memdesc:abf46cdc2fb411c33898ec61e3b0cb47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial number of virtual remote writers per instance.  <a href="#abf46cdc2fb411c33898ec61e3b0cb47e">More...</a><br /></td></tr>
<tr class="separator:abf46cdc2fb411c33898ec61e3b0cb47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204418dc2de40747e1717e0ddfee942a"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a204418dc2de40747e1717e0ddfee942a">max_remote_writers_per_sample</a></td></tr>
<tr class="memdesc:a204418dc2de40747e1717e0ddfee942a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of remote writers allowed to write the same sample.  <a href="#a204418dc2de40747e1717e0ddfee942a">More...</a><br /></td></tr>
<tr class="separator:a204418dc2de40747e1717e0ddfee942a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c411b590dc8a1294b014815a42ebab"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a77c411b590dc8a1294b014815a42ebab">max_query_condition_filters</a></td></tr>
<tr class="memdesc:a77c411b590dc8a1294b014815a42ebab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of query condition filters a reader is allowed.  <a href="#a77c411b590dc8a1294b014815a42ebab">More...</a><br /></td></tr>
<tr class="separator:a77c411b590dc8a1294b014815a42ebab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0e0586c5ba83cab401e6f16918af9e"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a6f0e0586c5ba83cab401e6f16918af9e">max_app_ack_response_length</a></td></tr>
<tr class="memdesc:a6f0e0586c5ba83cab401e6f16918af9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of application-level acknowledgment response data.  <a href="#a6f0e0586c5ba83cab401e6f16918af9e">More...</a><br /></td></tr>
<tr class="separator:a6f0e0586c5ba83cab401e6f16918af9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d2017fbb047eb472367ac881905202"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#ae7d2017fbb047eb472367ac881905202">initial_topic_queries</a></td></tr>
<tr class="memdesc:ae7d2017fbb047eb472367ac881905202"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial number of TopicQueries allocated by a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a>.  <a href="#ae7d2017fbb047eb472367ac881905202">More...</a><br /></td></tr>
<tr class="separator:ae7d2017fbb047eb472367ac881905202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec09a92827c1c0c9e699598b6af38e6d"><td class="memItemLeft" align="right" valign="top">System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#aec09a92827c1c0c9e699598b6af38e6d">max_topic_queries</a></td></tr>
<tr class="memdesc:aec09a92827c1c0c9e699598b6af38e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of active TopicQueries that a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> can create.  <a href="#aec09a92827c1c0c9e699598b6af38e6d">More...</a><br /></td></tr>
<tr class="separator:aec09a92827c1c0c9e699598b6af38e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a525ec5fd67ef9b24e6913affed4e5265"><td class="memItemLeft" align="right" valign="top">System::Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a525ec5fd67ef9b24e6913affed4e5265">disable_fragmentation_support</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a525ec5fd67ef9b24e6913affed4e5265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> can receive fragmented samples.  <a href="#a525ec5fd67ef9b24e6913affed4e5265">More...</a><br /></td></tr>
<tr class="separator:a525ec5fd67ef9b24e6913affed4e5265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e9169c8f98136b35716eee169d18e8"><td class="memItemLeft" align="right" valign="top">System::Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a92e9169c8f98136b35716eee169d18e8">dynamically_allocate_fragmented_samples</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a92e9169c8f98136b35716eee169d18e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> pre-allocates storage for storing fragmented samples.  <a href="#a92e9169c8f98136b35716eee169d18e8">More...</a><br /></td></tr>
<tr class="separator:a92e9169c8f98136b35716eee169d18e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85f9ee532c278ab0466cd741bc5dfdb3"><td class="memItemLeft" align="right" valign="top">static System::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DDSDataReaderResourceLimitsQosModule.html#ga85f9ee532c278ab0466cd741bc5dfdb3">AUTO_MAX_TOTAL_INSTANCES</a><code> [get]</code></td></tr>
<tr class="memdesc:ga85f9ee532c278ab0466cd741bc5dfdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em><a class="el" href="group__DDSDocGuideModule.html#a_st_ext">&lt;&lt;extension&gt;&gt;</a></em> This value is used to make <a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a1d244479c2f9e22add97287395f9f9fe" title="Maximum number of instances for which a DataReader will keep state. ">DDS::DataReaderResourceLimitsQosPolicy::max_total_instances</a> equal to <a class="el" href="structDDS_1_1ResourceLimitsQosPolicy.html#adac41a0cb3591d7abafeef03fce0c932" title="Represents the maximum number of instances a DDS::DataWriter (or DDS::DataReader) can manage...">DDS::ResourceLimitsQosPolicy::max_instances</a>.  <a href="group__DDSDataReaderResourceLimitsQosModule.html#ga85f9ee532c278ab0466cd741bc5dfdb3">More...</a><br /></td></tr>
<tr class="separator:ga85f9ee532c278ab0466cd741bc5dfdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58204a359b598d5b7d980e680019d753"><td class="memItemLeft" align="right" valign="top">System::Boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a58204a359b598d5b7d980e680019d753">keep_minimum_state_for_instances</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a58204a359b598d5b7d980e680019d753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not keep a minimum instance state for up to <a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a1d244479c2f9e22add97287395f9f9fe" title="Maximum number of instances for which a DataReader will keep state. ">DDS::DataReaderResourceLimitsQosPolicy::max_total_instances</a>.  <a href="#a58204a359b598d5b7d980e680019d753">More...</a><br /></td></tr>
<tr class="separator:a58204a359b598d5b7d980e680019d753"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Various settings that configure how a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> allocates and uses physical memory for internal resources. </p>
<p>DataReaders must allocate internal structures to handle the maximum number of DataWriters that may connect to it, whether or not a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> handles data fragmentation and how many data fragments that it may handle (for data samples larger than the MTU of the underlying network transport), how many simultaneous outstanding loans of internal memory holding data samples can be provided to user code, as well as others. </p>
<p>Most of these internal structures start at an initial size and, by default, will grow as needed by dynamically allocating additional memory. You may set fixed, maximum sizes for these internal structures if you want to bound the amount of memory that can be used by a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a>. By setting the initial size to the maximum size, you will prevent <a class="el" href="namespaceRTI.html">RTI</a> Connext from dynamically allocating any memory after the creation of the <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a>. </p>
<p>This QoS policy is an extension to the DDS standard. </p>
<dl class="section user"><dt>Entity:</dt><dd><a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> </dd></dl>
<dl class="section user"><dt>Properties:</dt><dd><a class="el" href="group__DDSQosTypesModule.html#a_prop_rxo">RxO</a> = N/A <br />
 <a class="el" href="group__DDSQosTypesModule.html#a_prop_changeable">Changeable</a> = <a class="el" href="group__DDSQosTypesModule.html#a_prop_changeable_no">NO</a> <br />
 </dd></dl>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="a5f57b1e4f05c3c4f6de0715b6c4e1557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f57b1e4f05c3c4f6de0715b6c4e1557">&#9670;&nbsp;</a></span>max_remote_writers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::max_remote_writers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of remote writers from which a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> may read, including all instances. </p>
<p><b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a> <br />
 <b>[range]</b> [1, 1 million] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a>, &gt;= initial_remote_writers, &gt;= max_remote_writers_per_instance </p>
<p>For unkeyed types, this value has to be equal to max_remote_writers_per_instance if max_remote_writers_per_instance is not equal to <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a>. </p>
<p>Note: For efficiency, set <code>max_remote_writers</code> &gt;= <a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#aab70a031ea118a15dd73b568ba191b5d" title="The maximum number of remote writers from which a DDS::DataReader may read a single instance...">DDS::DataReaderResourceLimitsQosPolicy::max_remote_writers_per_instance</a>. </p>

</div>
</div>
<a id="aab70a031ea118a15dd73b568ba191b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab70a031ea118a15dd73b568ba191b5d">&#9670;&nbsp;</a></span>max_remote_writers_per_instance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::max_remote_writers_per_instance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of remote writers from which a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> may read a single instance. </p>
<p><b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a> <br />
 </p>
<p><b>[range]</b> [1, 1024] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a>, &lt;= max_remote_writers or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a>, &gt;= initial_remote_writers_per_instance </p>
<p>For unkeyed types, this value has to be equal to max_remote_writers if it is not <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a>. </p>
<p>Note: For efficiency, set <code>max_remote_writers_per_instance</code> &lt;= <a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a5f57b1e4f05c3c4f6de0715b6c4e1557" title="The maximum number of remote writers from which a DDS::DataReader may read, including all instances...">DDS::DataReaderResourceLimitsQosPolicy::max_remote_writers</a> </p>

</div>
</div>
<a id="ab6b364722d6cbbf8b11c1a0619bc4e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b364722d6cbbf8b11c1a0619bc4e5a">&#9670;&nbsp;</a></span>max_samples_per_remote_writer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::max_samples_per_remote_writer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of out-of-order samples from a given remote <a class="el" href="classDDS_1_1DataWriter.html" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS::T...">DDS::DataWriter</a> that a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> may store when maintaining a reliable connection to the <a class="el" href="classDDS_1_1DataWriter.html" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS::T...">DDS::DataWriter</a>. </p>
<p><b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a> </p>
<p><b>[range]</b> [1, 100 million] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a>, &lt;= <a class="el" href="structDDS_1_1ResourceLimitsQosPolicy.html#a514b15faae5b2af668fd4cb2109c0a32" title="Represents the maximum samples the middleware can store for any one DDS::DataWriter (or DDS::DataRead...">DDS::ResourceLimitsQosPolicy::max_samples</a> </p>

</div>
</div>
<a id="abcdd444deb92af8c9ac5761ea92c9ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcdd444deb92af8c9ac5761ea92c9ba2">&#9670;&nbsp;</a></span>max_infos</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::max_infos</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of info units that a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> can use to store <a class="el" href="classDDS_1_1SampleInfo.html" title="Information that accompanies each sample that is read or taken. ">DDS::SampleInfo</a>. </p>
<p>When read/take is called on a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DataReader</a>, the <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DataReader</a> passes a sequence of data samples and an associated sample info sequence. The sample info sequence contains additional information for each data sample. </p>
<p>max_infos determines the resources allocated for storing sample info. This memory is loaned to the application when passing a sample info sequence. </p>
<p>Note that sample info is a snapshot, generated when read/take is called. </p>
<p>max_infos should not be less than max_samples. </p>
<p><b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a> </p>
<p><b>[range]</b> [1, 1 million] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a>, &gt;= initial_infos </p>

</div>
</div>
<a id="a7e2be6e7ad0a8d568d76b42cfd6406d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2be6e7ad0a8d568d76b42cfd6406d8">&#9670;&nbsp;</a></span>initial_remote_writers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::initial_remote_writers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial number of remote writers from which a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> may read, including all instances. </p>
<p><b>[default]</b> 2<br />
 </p>
<p><b>[range]</b> [1, 1 million], &lt;= max_remote_writers<br />
 </p>
<p>For unkeyed types this value has to be equal to initial_remote_writers_per_instance.<br />
 </p>
<p>Note: For efficiency, set initial_remote_writers &gt;= <a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a0f69e4c7da43e1013af9175357b778a7" title="The initial number of remote writers from which a DDS::DataReader may read a single instance...">DDS::DataReaderResourceLimitsQosPolicy::initial_remote_writers_per_instance</a>. </p>

</div>
</div>
<a id="a0f69e4c7da43e1013af9175357b778a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f69e4c7da43e1013af9175357b778a7">&#9670;&nbsp;</a></span>initial_remote_writers_per_instance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::initial_remote_writers_per_instance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial number of remote writers from which a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> may read a single instance. </p>
<p><b>[default]</b> 2<br />
 </p>
<p><b>[range]</b> [1,1024], &lt;= max_remote_writers_per_instance<br />
 </p>
<p>For unkeyed types this value has to be equal to initial_remote_writers.<br />
 </p>
<p>Note: For efficiency, set initial_remote_writers_per_instance &lt;= <a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a7e2be6e7ad0a8d568d76b42cfd6406d8" title="The initial number of remote writers from which a DDS::DataReader may read, including all instances...">DDS::DataReaderResourceLimitsQosPolicy::initial_remote_writers</a>. </p>

</div>
</div>
<a id="a14640233f62cb33b02bfef85bf4e9ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14640233f62cb33b02bfef85bf4e9ce3">&#9670;&nbsp;</a></span>initial_infos</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::initial_infos</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial number of info units that a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> can have, which are used to store <a class="el" href="classDDS_1_1SampleInfo.html" title="Information that accompanies each sample that is read or taken. ">DDS::SampleInfo</a>. </p>
<p><b>[default]</b> 32 </p>
<p><b>[range]</b> [1,1 million], &lt;= max_infos </p>

</div>
</div>
<a id="aaca67d5c4a2afc4a709d0e9708f0ef26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca67d5c4a2afc4a709d0e9708f0ef26">&#9670;&nbsp;</a></span>initial_outstanding_reads</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::initial_outstanding_reads</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial number of outstanding calls to read/take (or one of their variants) on the same <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> for which memory has not been returned by calling <a class="el" href="classDDS_1_1TypedDataReader.html#aa4a65c964bb5839b80452e5c2da98175" title="Indicates to the DDS::DataReader that the application is done accessing the collection of received_da...">DDS::TypedDataReader::return_loan</a>. </p>
<p><b>[default]</b> 2 </p>
<p><b>[range]</b> [1, 65536], &lt;= max_outstanding_reads </p>

</div>
</div>
<a id="a79c643911069a1b96f7812fb01d7b185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c643911069a1b96f7812fb01d7b185">&#9670;&nbsp;</a></span>max_outstanding_reads</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::max_outstanding_reads</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of outstanding read/take calls (or one of their variants) on the same <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> for which memory has not been returned by calling <a class="el" href="classDDS_1_1TypedDataReader.html#aa4a65c964bb5839b80452e5c2da98175" title="Indicates to the DDS::DataReader that the application is done accessing the collection of received_da...">DDS::TypedDataReader::return_loan</a>. </p>
<p><b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a> </p>
<p><b>[range]</b> [1, 65536] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a>, &gt;= initial_outstanding_reads </p>

</div>
</div>
<a id="a3cb4995f9adb75d1466605e684655d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb4995f9adb75d1466605e684655d3a">&#9670;&nbsp;</a></span>max_samples_per_read</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::max_samples_per_read</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of data samples that the application can receive from the middleware in a single call to <a class="el" href="classDDS_1_1TypedDataReader.html#a246446798ef356f99fa05ea8a4c5df6a" title="Access a collection of data samples from the DDS::DataReader. ">DDS::TypedDataReader::read</a> or <a class="el" href="classDDS_1_1TypedDataReader.html#aaed9fdf9e5442732cd3a2dae0e606043" title="Access a collection of data-samples from the DDS::DataReader. ">DDS::TypedDataReader::take</a>. If more data exists in the middleware, the application will need to issue multiple read/take calls. </p>
<p>When reading data using listeners, the expected number of samples available for delivery in a single <code>take</code> call is typically small: usually just one, in the case of unbatched data, or the number of samples in a single batch, in the case of batched data. (See <a class="el" href="structDDS_1_1BatchQosPolicy.html" title="Used to configure batching of multiple samples into a single network packet in order to increase thro...">DDS::BatchQosPolicy</a> for more information about this feature.) When polling for data or using a <a class="el" href="classDDS_1_1WaitSet.html" title="&lt;&lt;interface&gt;&gt; Allows an application to wait until one or more of the attached DDS::Condition objects ...">DDS::WaitSet</a>, however, multiple samples (or batches) could be retrieved at once, depending on the data rate. </p>
<p>A larger value for this parameter makes the API simpler to use at the expense of some additional memory consumption. </p>
<p><b>[default]</b> 1024 </p>
<p><b>[range]</b> [1,65536] </p>

</div>
</div>
<a id="ae83759e3f07a3879b0f53f438f7a9761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83759e3f07a3879b0f53f438f7a9761">&#9670;&nbsp;</a></span>max_fragmented_samples</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::max_fragmented_samples</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of samples for which the <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> may store fragments at a given point in time. </p>
<p>At any given time, a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> may store fragments for up to <code>max_fragmented_samples</code> samples while waiting for the remaining fragments. These samples need not have consecutive sequence numbers and may have been sent by different <a class="el" href="classDDS_1_1DataWriter.html" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS::T...">DDS::DataWriter</a> instances. </p>
<p>Once all fragments of a sample have been received, the sample is treated as a regular sample and becomes subject to standard QoS settings such as <a class="el" href="structDDS_1_1ResourceLimitsQosPolicy.html#a514b15faae5b2af668fd4cb2109c0a32" title="Represents the maximum samples the middleware can store for any one DDS::DataWriter (or DDS::DataRead...">DDS::ResourceLimitsQosPolicy::max_samples</a>. </p>
<p>The middleware will drop fragments if the <code>max_fragmented_samples</code> limit has been reached. For best-effort communication, the middleware will accept a fragment for a new sample, but drop the oldest fragmented sample from the same remote writer. For reliable communication, the middleware will drop fragments for any new samples until all fragments for at least one older sample from that writer have been received. </p>
<p>Only applies if <a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a525ec5fd67ef9b24e6913affed4e5265" title="Determines whether the DDS::DataReader can receive fragmented samples. ">DDS::DataReaderResourceLimitsQosPolicy::disable_fragmentation_support</a> is false. </p>
<p><b>[default]</b> 1024 </p>
<p><b>[range]</b> [1, 1 million] </p>

</div>
</div>
<a id="a493dff26d01c8d6951313253a67b1e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493dff26d01c8d6951313253a67b1e2b">&#9670;&nbsp;</a></span>initial_fragmented_samples</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::initial_fragmented_samples</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial number of samples for which a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> may store fragments. </p>
<p>Only applies if <a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a525ec5fd67ef9b24e6913affed4e5265" title="Determines whether the DDS::DataReader can receive fragmented samples. ">DDS::DataReaderResourceLimitsQosPolicy::disable_fragmentation_support</a> is false. </p>
<p><b>[default]</b> 4 </p>
<p><b>[range]</b> [1,1024], &lt;= max_fragmented_samples </p>

</div>
</div>
<a id="aea8a81f8b0e91b7e016f11882342bd69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8a81f8b0e91b7e016f11882342bd69">&#9670;&nbsp;</a></span>max_fragmented_samples_per_remote_writer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::max_fragmented_samples_per_remote_writer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of samples per remote writer for which a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> may store fragments. </p>
<p>Logical limit so a single remote writer cannot consume all available resources. </p>
<p>Only applies if <a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a525ec5fd67ef9b24e6913affed4e5265" title="Determines whether the DDS::DataReader can receive fragmented samples. ">DDS::DataReaderResourceLimitsQosPolicy::disable_fragmentation_support</a> is false. </p>
<p><b>[default]</b> 256 </p>
<p><b>[range]</b> [1, 1 million], &lt;= max_fragmented_samples </p>

</div>
</div>
<a id="ad9f42abe5e3cbf5306eeaeae5811f2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f42abe5e3cbf5306eeaeae5811f2ca">&#9670;&nbsp;</a></span>max_fragments_per_sample</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::max_fragments_per_sample</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of fragments for a single sample. </p>
<p>Only applies if <a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a525ec5fd67ef9b24e6913affed4e5265" title="Determines whether the DDS::DataReader can receive fragmented samples. ">DDS::DataReaderResourceLimitsQosPolicy::disable_fragmentation_support</a> is false. </p>
<p><b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a> </p>
<p><b>[range]</b> [1, 1 million] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a> </p>

</div>
</div>
<a id="a1d244479c2f9e22add97287395f9f9fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d244479c2f9e22add97287395f9f9fe">&#9670;&nbsp;</a></span>max_total_instances</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::max_total_instances</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of instances for which a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DataReader</a> will keep state. </p>
<p>The maximum number of instances actively managed by a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DataReader</a> is determined by <a class="el" href="structDDS_1_1ResourceLimitsQosPolicy.html#adac41a0cb3591d7abafeef03fce0c932" title="Represents the maximum number of instances a DDS::DataWriter (or DDS::DataReader) can manage...">DDS::ResourceLimitsQosPolicy::max_instances</a>. </p>
<p>These instances have associated DataWriters or samples in the <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DataReader</a>'s queue and are visible to the user through operations such as <a class="el" href="classDDS_1_1TypedDataReader.html#aaed9fdf9e5442732cd3a2dae0e606043" title="Access a collection of data-samples from the DDS::DataReader. ">DDS::TypedDataReader::take</a>, <a class="el" href="classDDS_1_1TypedDataReader.html#a246446798ef356f99fa05ea8a4c5df6a" title="Access a collection of data samples from the DDS::DataReader. ">DDS::TypedDataReader::read</a>, and <a class="el" href="classDDS_1_1TypedDataReader.html#a77bdcc78f7cb88a8c950b56ab43528d6" title="Retrieve the instance key that corresponds to an instance handle. ">DDS::TypedDataReader::get_key_value</a>. </p>
<p>The features Durable Reader State, MultiChannel DataWriters and <a class="el" href="namespaceRTI.html">RTI</a> Persistence Service require <a class="el" href="namespaceRTI.html">RTI</a> Connext to keep some internal state even for instances without DataWriters or samples in the <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DataReader</a>'s queue. The additional state is used to filter duplicate samples that could be coming from different <a class="el" href="classDDS_1_1DataWriter.html" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS::T...">DataWriter</a> channels or from multiple executions of <a class="el" href="namespaceRTI.html">RTI</a> Persistence Service. </p>
<p>The total maximum number of instances that will be managed by the middleware, including instances without associated DataWriters or samples, is determined by max_total_instances. </p>
<p>When a new instance is received, <a class="el" href="namespaceRTI.html">RTI</a> Connext will check the resource limit <a class="el" href="structDDS_1_1ResourceLimitsQosPolicy.html#adac41a0cb3591d7abafeef03fce0c932" title="Represents the maximum number of instances a DDS::DataWriter (or DDS::DataReader) can manage...">DDS::ResourceLimitsQosPolicy::max_instances</a>. If the limit is exceeded, <a class="el" href="namespaceRTI.html">RTI</a> Connext will drop the sample and report it as lost and rejected. If the limit is not exceeded, <a class="el" href="namespaceRTI.html">RTI</a> Connext will check max_total_instances. If max_total_instances is exceeded, <a class="el" href="namespaceRTI.html">RTI</a> Connext will replace an existing instance without DataWriters and samples with the new one. The application could receive duplicate samples for the replaced instance if it becomes alive again. </p>
<p><b>[default]</b> <a class="el" href="group__DDSDataReaderResourceLimitsQosModule.html#ga85f9ee532c278ab0466cd741bc5dfdb3" title="&lt;&lt;extension&gt;&gt; This value is used to make DDS::DataReaderResourceLimitsQosPolicy::max_total_instances ...">DDS::DataReaderResourceLimitsQosPolicy::AUTO_MAX_TOTAL_INSTANCES</a> </p>
<p><b>[range]</b> [1, 1 million] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a> or <a class="el" href="group__DDSDataReaderResourceLimitsQosModule.html#ga85f9ee532c278ab0466cd741bc5dfdb3" title="&lt;&lt;extension&gt;&gt; This value is used to make DDS::DataReaderResourceLimitsQosPolicy::max_total_instances ...">DDS::DataReaderResourceLimitsQosPolicy::AUTO_MAX_TOTAL_INSTANCES</a>, &gt;= <a class="el" href="structDDS_1_1ResourceLimitsQosPolicy.html#adac41a0cb3591d7abafeef03fce0c932" title="Represents the maximum number of instances a DDS::DataWriter (or DDS::DataReader) can manage...">DDS::ResourceLimitsQosPolicy::max_instances</a> </p>

</div>
</div>
<a id="a7af32ce6df34f0adf64bb83d56ead4ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af32ce6df34f0adf64bb83d56ead4ce">&#9670;&nbsp;</a></span>max_remote_virtual_writers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::max_remote_virtual_writers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of remote virtual writers from which a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> may read, including all instances. </p>
<p>When <a class="el" href="structDDS_1_1PresentationQosPolicy.html#a0813782222f89fc037975abe2f1e78ce" title="Determines the largest scope spanning the entities for which the order and coherency of changes can b...">DDS::PresentationQosPolicy::access_scope</a> is set to <a class="el" href="group__DDSPresentationQosModule.html#gga187b08e5531a3849d3f21cec74e1f804ae6202d92e84c5f29f7f7150e4ddebfa0" title="Scope spans to all instances belonging to DDS::DataWriter (or DDS::DataReader) entities within the sa...">DDS::PresentationQosPolicyAccessScopeKind::GROUP_PRESENTATION_QOS</a>, this value determines the maximum number of <a class="el" href="classDDS_1_1DataWriter.html" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS::T...">DataWriter</a> groups that can be managed by the <a class="el" href="classDDS_1_1Subscriber.html" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS::Subscriber</a> containing this <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a>. </p>
<p>Since the <a class="el" href="classDDS_1_1Subscriber.html" title="&lt;&lt;interface&gt;&gt; A subscriber is the object responsible for actually receiving data from a subscription...">DDS::Subscriber</a> may contain more than one <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a>, only the setting of the first applies. </p>
<p><b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a> <br />
 <b>[range]</b> [1, 1 million] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a>, &gt;= initial_remote_virtual_writers, &gt;= max_remote_virtual_writers_per_instance </p>

</div>
</div>
<a id="a30cf9a7172bac66444f39e5b41e3b8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30cf9a7172bac66444f39e5b41e3b8d2">&#9670;&nbsp;</a></span>initial_remote_virtual_writers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::initial_remote_virtual_writers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial number of remote virtual writers from which a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> may read, including all instances. </p>
<p><b>[default]</b> 2 <br />
 <b>[range]</b> [1, 1 million] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a>, &lt;= max_remote_virtual_writers </p>

</div>
</div>
<a id="a297e95e927beb073eed8bb499303bfd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297e95e927beb073eed8bb499303bfd3">&#9670;&nbsp;</a></span>max_remote_virtual_writers_per_instance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::max_remote_virtual_writers_per_instance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of virtual remote writers that can be associated with an instance. </p>
<p><b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a> <br />
 </p>
<p><b>[range]</b> [1, 1024] or <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a>, &gt;= initial_remote_virtual_writers_per_instance </p>
<p>For unkeyed types, this value is ignored. </p>
<p>The features of Durable Reader State and MultiChannel DataWriters, and <a class="el" href="namespaceRTI.html">RTI</a> Persistence Service require <a class="el" href="namespaceRTI.html">RTI</a> Connext to keep some internal state per virtual writer and instance that is used to filter duplicate samples. These duplicate samples could be coming from different <a class="el" href="classDDS_1_1DataWriter.html" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS::T...">DataWriter</a> channels or from multiple executions of <a class="el" href="namespaceRTI.html">RTI</a> Persistence Service. </p>
<p>Once an association between a remote virtual writer and an instance is established, it is permanent &ndash; it will not disappear even if the physical writer incarnating the virtual writer is destroyed. </p>
<p>If max_remote_virtual_writers_per_instance is exceeded for an instance, <a class="el" href="namespaceRTI.html">RTI</a> Connext will not associate this instance with new virtual writers. Duplicates samples from these virtual writers will not be filtered on the reader. </p>
<p>If you are not using Durable Reader State, MultiChannel DataWriters or <a class="el" href="namespaceRTI.html">RTI</a> Persistence Service in your system, you can set this property to 1 to optimize resources. </p>

</div>
</div>
<a id="abf46cdc2fb411c33898ec61e3b0cb47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf46cdc2fb411c33898ec61e3b0cb47e">&#9670;&nbsp;</a></span>initial_remote_virtual_writers_per_instance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::initial_remote_virtual_writers_per_instance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial number of virtual remote writers per instance. </p>
<p><b>[default]</b> 2<br />
 </p>
<p><b>[range]</b> [1, 1024], &lt;= max_remote_virtual_writers_per_instance<br />
 </p>
<p>For unkeyed types, this value is ignored.<br />
 </p>

</div>
</div>
<a id="a204418dc2de40747e1717e0ddfee942a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204418dc2de40747e1717e0ddfee942a">&#9670;&nbsp;</a></span>max_remote_writers_per_sample</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::max_remote_writers_per_sample</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of remote writers allowed to write the same sample. </p>
<p>One scenario in which two DataWriters may write the same sample is Persistence Service. The <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DataReader</a> may receive the same sample coming from the original <a class="el" href="classDDS_1_1DataWriter.html" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS::T...">DataWriter</a> and from a Persistence Service <a class="el" href="classDDS_1_1DataWriter.html" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS::T...">DataWriter</a>. <b>[default]</b> 3<br />
 </p>
<p><b>[range]</b> [1, 1024]<br />
 </p>

</div>
</div>
<a id="a77c411b590dc8a1294b014815a42ebab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c411b590dc8a1294b014815a42ebab">&#9670;&nbsp;</a></span>max_query_condition_filters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::max_query_condition_filters</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of query condition filters a reader is allowed. </p>
<p><b>[default]</b> 4<br />
 </p>
<p><b>[range]</b> [0, 32]<br />
 </p>
<p>This value determines the maximum number of unique query condition content filters that a reader may create. </p>
<p>Each query condition content filter is comprised of both its <code>query_expression</code> and <code>query_parameters</code>. Two query conditions that have the same <code>query_expression</code> will require unique query condition filters if their <code>query_paramters</code> differ. Query conditions that differ only in their state masks will share the same query condition filter. </p>

</div>
</div>
<a id="a6f0e0586c5ba83cab401e6f16918af9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0e0586c5ba83cab401e6f16918af9e">&#9670;&nbsp;</a></span>max_app_ack_response_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::max_app_ack_response_length</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum length of application-level acknowledgment response data. </p>
<p>The maximum length of response data in an application-level acknowledgment. </p>
<p>When set to zero, no response data is sent with application-level acknowledgments. </p>
<p><b>[default]</b> 0 </p>
<p><b>[range]</b> [0, 65536] </p>

</div>
</div>
<a id="ae7d2017fbb047eb472367ac881905202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d2017fbb047eb472367ac881905202">&#9670;&nbsp;</a></span>initial_topic_queries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::initial_topic_queries</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial number of TopicQueries allocated by a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a>. </p>
<p><b>[default]</b> 1 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classDDS_1_1TopicQuery.html" title="&lt;&lt;extension&gt;&gt; Allows a DDS::DataReader to query the sample cache of its matching DDS::DataWriter. ">DDS::TopicQuery</a> </dd></dl>

</div>
</div>
<a id="aec09a92827c1c0c9e699598b6af38e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec09a92827c1c0c9e699598b6af38e6d">&#9670;&nbsp;</a></span>max_topic_queries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::Int32 DDS::DataReaderResourceLimitsQosPolicy::max_topic_queries</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of active TopicQueries that a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> can create. </p>
<p>Once this limit is reached, a <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> can create more TopicQueries only if it deletes some of the previously created ones. </p>
<p><b>[default]</b> <a class="el" href="group__DDSResourceLimitsQosModule.html#ga76492da059e18763c476bba56188542b" title="A special value indicating an unlimited quantity. ">DDS::ResourceLimitsQosPolicy::LENGTH_UNLIMITED</a> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classDDS_1_1TopicQuery.html" title="&lt;&lt;extension&gt;&gt; Allows a DDS::DataReader to query the sample cache of its matching DDS::DataWriter. ">DDS::TopicQuery</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a id="a525ec5fd67ef9b24e6913affed4e5265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525ec5fd67ef9b24e6913affed4e5265">&#9670;&nbsp;</a></span>disable_fragmentation_support</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">System:: Boolean DDS::DataReaderResourceLimitsQosPolicy::disable_fragmentation_support</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> can receive fragmented samples. </p>
<p>When fragmentation support is not needed, disabling fragmentation support will save some memory resources. </p>
<p><b>[default]</b> false </p>

</div>
</div>
<a id="a92e9169c8f98136b35716eee169d18e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e9169c8f98136b35716eee169d18e8">&#9670;&nbsp;</a></span>dynamically_allocate_fragmented_samples</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">System:: Boolean DDS::DataReaderResourceLimitsQosPolicy::dynamically_allocate_fragmented_samples</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DDS::DataReader</a> pre-allocates storage for storing fragmented samples. </p>
<p>By default, the middleware does not allocate memory upfront, but instead allocates memory from the heap upon receiving the first fragment of a new sample. The amount of memory allocated equals the amount of memory needed to store all fragments in the sample. Once all fragments of a sample have been received, the sample is deserialized and stored in the regular receive queue. At that time, the dynamically allocated memory is freed again. </p>
<p>This QoS setting is useful for large, but variable-sized data types where upfront memory allocation for multiple samples based on the maximum possible sample size may be expensive. The main disadvantage of not pre-allocating memory is that one can no longer guarantee the middleware will have sufficient resources at run-time. </p>
<p>If <code>dynamically_allocate_fragmented_samples</code> is set to false, the middleware will allocate memory upfront for storing fragments for up to <a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a493dff26d01c8d6951313253a67b1e2b" title="The initial number of samples for which a DDS::DataReader may store fragments. ">DDS::DataReaderResourceLimitsQosPolicy::initial_fragmented_samples</a> samples. This memory may grow up to <a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#ae83759e3f07a3879b0f53f438f7a9761" title="The maximum number of samples for which the DDS::DataReader may store fragments at a given point in t...">DDS::DataReaderResourceLimitsQosPolicy::max_fragmented_samples</a> if needed. </p>
<p>Only applies if <a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a525ec5fd67ef9b24e6913affed4e5265" title="Determines whether the DDS::DataReader can receive fragmented samples. ">DDS::DataReaderResourceLimitsQosPolicy::disable_fragmentation_support</a> is false. </p>
<p><b>[default]</b> true </p>

</div>
</div>
<a id="a58204a359b598d5b7d980e680019d753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58204a359b598d5b7d980e680019d753">&#9670;&nbsp;</a></span>keep_minimum_state_for_instances</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">System:: Boolean DDS::DataReaderResourceLimitsQosPolicy::keep_minimum_state_for_instances</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether or not keep a minimum instance state for up to <a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a1d244479c2f9e22add97287395f9f9fe" title="Maximum number of instances for which a DataReader will keep state. ">DDS::DataReaderResourceLimitsQosPolicy::max_total_instances</a>. </p>
<p>The features Durable Reader State, multi-channel DataWriters, and Persistence Service require <a class="el" href="namespaceRTI.html">RTI</a> Connext to keep some minimal internal state even for instances without DataWriters or DDS samples in the <a class="el" href="classDDS_1_1DataReader.html" title="&lt;&lt;interface&gt;&gt; Allows the application to: (1) declare the data it wishes to receive (i...">DataReader</a>'s queue, or that have been purged due to a dispose. The additional state is used to filter duplicate DDS samples that could be coming from different <a class="el" href="classDDS_1_1DataWriter.html" title="&lt;&lt;interface&gt;&gt; Allows an application to set the value of the data to be published under a given DDS::T...">DataWriter</a> channels or from multiple executions of Persistence Service. The total maximum number of instances that will be managed by the middleware, including instances without associated DataWriters or DDS samples or that have been purged due to a dispose, is determined by <a class="el" href="structDDS_1_1DataReaderResourceLimitsQosPolicy.html#a1d244479c2f9e22add97287395f9f9fe" title="Maximum number of instances for which a DataReader will keep state. ">DDS::DataReaderResourceLimitsQosPolicy::max_total_instances</a>. </p>
<p>This additional state will only be kept for up to max_total_instances if this field is set to true, otherwise the additional state will not be kept for any instances. </p>
<p><b>[default]</b> true </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<HR>
<IMG SRC="rti_logo.gif" height="16">
<A HREF="main.html">RTI Connext .Net APIs Version 5.3.0</A>
Copyright &copy; Sun Jun 25 2017 
<A HREF="http://www.rti.com">Real-Time Innovations, Inc</A>
</BODY>
</HTML>
